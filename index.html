<!doctype html>
<html lang="zh-Hans">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="theme-color" content="#0b2a1d" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <title>Hand-Controlled Christmas Tree â€” THREE.js + MediaPipe Hands</title>

  <style>
    :root{
      --bg0:#06160f;
      --bg1:#0b2a1d;
      --gold:#c7a54f;
      --gold2:#ffd57a;
      --red:#c0162b;
      --green:#1f6b45;
      --ui:rgba(8,18,14,.55);
      --ui2:rgba(10,26,19,.70);
      --line:rgba(255,213,122,.22);
      --text:rgba(255,246,230,.92);
      --muted:rgba(255,246,230,.70);
      --shadow: 0 18px 60px rgba(0,0,0,.55);
    }
    *{box-sizing:border-box}
    html,body{
      height:100%; margin:0;
      background:radial-gradient(1200px 700px at 40% 15%, #124332 0%, var(--bg1) 35%, var(--bg0) 85%);
      overflow:hidden; color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "PingFang SC","Noto Sans CJK SC","Microsoft YaHei";
      touch-action:none; user-select:none;
    }
    #app{position:fixed; inset:0;}
    canvas#gl{position:absolute; inset:0; width:100%; height:100%; display:block;}

    #grain{
      pointer-events:none; position:absolute; inset:0;
      background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='260' height='260'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.9' numOctaves='2' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='260' height='260' filter='url(%23n)' opacity='.22'/%3E%3C/svg%3E");
      mix-blend-mode:overlay; opacity:.20;
    }

    #hud{
      position:absolute; left:14px; top:14px;
      width:min(560px, calc(100vw - 28px));
      padding:14px 14px 12px;
      border:1px solid var(--line);
      border-radius:16px;
      background:linear-gradient(180deg, var(--ui2), var(--ui));
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }
    #hud .title{display:flex; align-items:center; gap:10px; font-weight:750; letter-spacing:.3px}
    .dot{
      width:10px; height:10px; border-radius:999px;
      background: radial-gradient(circle at 30% 30%, var(--gold2), var(--gold));
      box-shadow: 0 0 14px rgba(255,213,122,.40);
    }
    #hud .sub{margin-top:6px; font-size:12px; color:var(--muted); line-height:1.45}
    #hud .row{margin-top:10px; display:flex; flex-wrap:wrap; gap:10px; align-items:center}

    .btn{
      cursor:pointer;
      border:1px solid rgba(255,213,122,.26);
      background:linear-gradient(180deg, rgba(199,165,79,.14), rgba(192,22,43,.08));
      color:var(--text);
      padding:10px 12px;
      border-radius:12px;
      font-weight:700;
      letter-spacing:.2px;
      box-shadow: 0 10px 30px rgba(0,0,0,.28);
      transition: transform .12s ease, filter .12s ease;
    }
    .btn:hover{transform: translateY(-1px); filter:brightness(1.05)}
    .btn:active{transform: translateY(0px); filter:brightness(.98)}
    .btn.secondary{
      border-color: rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      font-weight:650;
      box-shadow:none;
    }
    input[type="file"]{display:none}
    label.file{
      cursor:pointer;
      display:inline-flex; align-items:center; gap:8px;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid rgba(255,213,122,.18);
      background:rgba(255,255,255,.06);
      font-size:12px;
      user-select:none;
    }

    .badge{
      margin-left:auto;
      padding:6px 10px;
      border-radius:999px;
      font-size:12px;
      border:1px solid rgba(255,213,122,.20);
      background:rgba(0,0,0,.22);
      color:rgba(255,246,230,.88);
      white-space:nowrap;
    }

    #gate{
      position:absolute; inset:0;
      display:flex; align-items:center; justify-content:center;
      padding:18px;
      background: radial-gradient(900px 500px at 50% 30%, rgba(255,213,122,.07), rgba(0,0,0,.65));
    }
    #gate .card{
      width:min(720px, 92vw);
      border-radius:22px;
      padding:18px 18px 16px;
      border:1px solid rgba(255,213,122,.22);
      background:linear-gradient(180deg, rgba(10,26,19,.78), rgba(8,18,14,.58));
      box-shadow: 0 24px 80px rgba(0,0,0,.65);
      backdrop-filter: blur(10px);
    }
    #gate .card h1{margin:0; font-size:18px; letter-spacing:.2px}
    #gate .card p{margin:10px 0 0; color:var(--muted); line-height:1.55; font-size:13px}
    #gate .card .actions{margin-top:14px; display:flex; gap:10px; flex-wrap:wrap; align-items:center}
    #gate .note{
      margin-top:10px;
      font-size:12px; color:rgba(255,246,230,.66);
      border-top:1px dashed rgba(255,255,255,.12);
      padding-top:10px;
    }

    #debugCam{
      position:absolute; right:14px; bottom:14px;
      width:min(340px, 48vw);
      aspect-ratio: 4 / 3;
      border-radius:16px;
      overflow:hidden;
      border:1px solid rgba(255,213,122,.20);
      box-shadow: var(--shadow);
      background: rgba(0,0,0,.25);
      display:none;
    }
    #debugCam canvas{width:100%; height:100%; display:block;}

    @media (max-width: 520px){
      #hud{left:10px; top:10px; width:calc(100vw - 20px)}
      #debugCam{right:10px; bottom:10px}
      .btn,label.file{padding:11px 12px}
    }
  </style>

  <!-- MediaPipe -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1675466862/camera_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.3.1675466124/drawing_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/hands.js" crossorigin="anonymous"></script>
</head>

<body>
  <div id="app">
    <canvas id="gl"></canvas>
    <div id="grain"></div>

    <div id="hud">
      <div class="title">
        <span class="dot"></span>
        <div>æ‰‹åŠ¿æ§åˆ¶ 3D ç²’å­ + ç…§ç‰‡äº‘åœ£è¯æ ‘</div>
        <div class="badge" id="statusBadge">STATE: CONE Â· GESTURE: â€” Â· PHOTOS: 0</div>
      </div>
      <div class="sub">
        <b>æ¡æ‹³</b>â†’åˆæ‹¢æˆæ ‘â€ƒ<b>äº”æŒ‡å¼ å¼€</b>â†’æ•£å¼€æ¼‚æµ®â€ƒ<b>æåˆ(æŠ“)</b>â†’æŠ“ä½ç…§ç‰‡æ”¾å¤§â€ƒ<b>æ‰‹æŒæ—‹è½¬/ç§»åŠ¨</b>â†’æ•£å¼€æ€æ—‹è½¬è§†è§’<br/>
        ä¹Ÿæ”¯æŒæµ‹è¯•ï¼š<b>é”®ç›˜ 1</b>åˆæ‹¢ <b>2</b>æ•£å¼€ <b>Esc</b>é€€å‡ºæ”¾å¤§ï¼Œç‚¹å‡»ç…§ç‰‡å¯æ”¾å¤§
      </div>
      <div class="row">
        <button class="btn" id="startBtn">ğŸ¥ å¯åŠ¨æ‘„åƒå¤´ & å¼€å§‹</button>
        <label class="file" for="photosInput">ğŸ–¼ï¸ ä¸Šä¼ ç…§ç‰‡ï¼ˆå¯é€‰ï¼‰
          <input id="photosInput" type="file" accept="image/*" multiple />
        </label>
        <button class="btn secondary" id="toggleDebug">ğŸ§ª è°ƒè¯•è§†å›¾</button>
      </div>
    </div>

    <div id="debugCam"><canvas id="debug2d"></canvas></div>

    <div id="gate">
      <div class="card">
        <h1>ğŸ„ ç”¨æ‰‹åŠ¿â€œæä½â€åœ£è¯æ ‘</h1>
        <p>
          è¿™ä¸ªç‰ˆæœ¬å†…ç½®äº†é»˜è®¤ç…§ç‰‡ï¼ˆä¸ä¸Šä¼ ä¹Ÿèƒ½çœ‹åˆ°ç…§ç‰‡äº‘ï¼‰ï¼Œå¹¶è°ƒä½äº†â€œé‡‘/äº®â€ï¼Œè®©ç»†èŠ‚æ›´æ¸…æ¥šã€‚<br/>
          <b>æ‰‹æœºä½¿ç”¨ï¼šéœ€è¦ HTTPS</b>ï¼ˆå¦åˆ™æ‘„åƒå¤´æ‰‹åŠ¿ä¼šè¢«æµè§ˆå™¨ç¦ç”¨ï¼‰ã€‚
        </p>
        <div class="actions">
          <button class="btn" id="gateStart">å¼€å§‹ï¼ˆæˆæƒæ‘„åƒå¤´ï¼‰</button>
          <button class="btn secondary" id="gateNoCam">ä»…è§‚çœ‹ï¼ˆæ— æ‰‹åŠ¿ï¼‰</button>
        </div>
        <div class="note">
          æ‰‹åŠ¿ï¼šæ¡æ‹³=åˆæ‹¢ï¼›äº”æŒ‡å¼ å¼€=æ•£å¼€ï¼›æ‹‡æŒ‡+é£ŸæŒ‡æåˆ=æŠ“ä½ç…§ç‰‡æ”¾å¤§ï¼›åœ¨æ•£å¼€æ€æ—‹è½¬/ç§»åŠ¨æ‰‹æŒå¯æ—‹è½¬è§†è§’ã€‚
        </div>
      </div>
    </div>

    <video id="video" playsinline muted style="display:none"></video>
  </div>

  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js";
    import { EffectComposer } from "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/postprocessing/EffectComposer.js";
    import { RenderPass } from "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/postprocessing/RenderPass.js";
    import { UnrealBloomPass } from "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/postprocessing/UnrealBloomPass.js";
    import { ShaderPass } from "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/postprocessing/ShaderPass.js";

    const clamp = (v, a, b) => Math.min(b, Math.max(a, v));
    const damp = (a, b, lambda, dt) => THREE.MathUtils.damp(a, b, lambda, dt);

    // ---------- state ----------
    const STATE = { CONE:"CONE", SCATTER:"SCATTER", PHOTO:"PHOTO" };
    let state = STATE.CONE;
    let selectedPhoto = null;

    const badge = document.getElementById("statusBadge");
    function setBadge(gestureLabel="â€”"){
      badge.textContent = `STATE: ${state} Â· GESTURE: ${gestureLabel} Â· PHOTOS: ${photoPlanes.length}`;
    }

    // ---------- renderer / scene ----------
    const canvas = document.getElementById("gl");
    const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;

    // äº®åº¦è°ƒä½ï¼ˆæ›´æ¸…æ¥šï¼‰
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 0.78;

    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x06160f, 0.052);

    const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 120);
    camera.position.set(0, 3.8, 14);

    // lightsï¼ˆæ•´ä½“æŸ”å’Œä¸€ç‚¹ï¼‰
    const key = new THREE.DirectionalLight(0xfff0d5, 0.90);
    key.position.set(6, 10, 6);
    scene.add(key);

    const fill = new THREE.DirectionalLight(0xffd57a, 0.30);
    fill.position.set(-8, 6, -7);
    scene.add(fill);

    const warmPoint = new THREE.PointLight(0xffc86b, 0.95, 45, 2);
    warmPoint.position.set(0, 7, 5);
    scene.add(warmPoint);

    const redGlow = new THREE.PointLight(0xff2a3d, 0.65, 35, 2);
    redGlow.position.set(-4, 2.5, 2);
    scene.add(redGlow);

    // background sphere
    const bg = new THREE.Mesh(
      new THREE.SphereGeometry(60, 48, 32),
      new THREE.MeshBasicMaterial({ color: 0x0b2a1d, side: THREE.BackSide, transparent:true, opacity: 0.95 })
    );
    scene.add(bg);

    // postprocessing
    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));

    // Bloom è°ƒä½ï¼ˆçœ‹æ¸…ç»“æ„ï¼‰
    const bloom = new UnrealBloomPass(
      new THREE.Vector2(innerWidth, innerHeight),
      0.55,   // strength
      0.55,   // radius
      0.28    // thresholdï¼ˆæé«˜é˜ˆå€¼ï¼Œå‡å°‘æ³›ç™½ï¼‰
    );
    composer.addPass(bloom);

    const VignetteGrainShader = {
      uniforms: {
        tDiffuse: { value: null },
        uTime: { value: 0 },
        uVig: { value: 0.40 },
        uGrain: { value: 0.05 }
      },
      vertexShader: `
        varying vec2 vUv;
        void main(){ vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0); }
      `,
      fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float uTime;
        uniform float uVig;
        uniform float uGrain;
        varying vec2 vUv;

        float hash(vec2 p){
          p = fract(p*vec2(123.34, 345.45));
          p += dot(p, p+34.345);
          return fract(p.x*p.y);
        }
        void main(){
          vec4 col = texture2D(tDiffuse, vUv);

          vec2 d = vUv - 0.5;
          float vig = smoothstep(0.85, 0.15, dot(d,d) * 1.75);
          col.rgb *= mix(1.0 - uVig, 1.0, vig);

          float n = hash(vUv * vec2(1920.0,1080.0) + uTime);
          col.rgb += (n - 0.5) * uGrain;

          gl_FragColor = col;
        }
      `
    };
    const vignettePass = new ShaderPass(VignetteGrainShader);
    composer.addPass(vignettePass);

    // ground
    const floor = new THREE.Mesh(
      new THREE.CircleGeometry(9.5, 64),
      new THREE.MeshStandardMaterial({
        color: 0x0b2a1d,
        metalness: 0.10,
        roughness: 0.92,
        emissive: 0x07140f,
        emissiveIntensity: 0.18
      })
    );
    floor.rotation.x = -Math.PI/2;
    floor.position.y = -2.2;
    scene.add(floor);

    const ROOT = new THREE.Group();
    scene.add(ROOT);

    const TREE = { height: 9.2, radius: 4.2, baseY: -2.0 };

    function conePose(i, n, jitter=0.26){
      const t = i / Math.max(1, n-1);
      const y = TREE.baseY + t * TREE.height;
      const r = (1.0 - t) * TREE.radius;
      const angle = i * 0.62 + t * 5.2;
      const x = Math.cos(angle) * r;
      const z = Math.sin(angle) * r;
      const jx = (Math.sin(i*12.9898)*43758.5453)%1 * jitter - jitter/2;
      const jz = (Math.sin(i*78.233)*  9623.673)%1 * jitter - jitter/2;
      return new THREE.Vector3(x + jx, y, z + jz);
    }
    function randomInShell(rMin, rMax){
      const u = Math.random(), v = Math.random();
      const theta = 2*Math.PI*u;
      const phi = Math.acos(2*v - 1);
      const r = THREE.MathUtils.lerp(rMin, rMax, Math.random());
      return new THREE.Vector3(
        r*Math.sin(phi)*Math.cos(theta),
        r*Math.cos(phi),
        r*Math.sin(phi)*Math.sin(theta)
      );
    }

    // candy stripe texture
    function makeStripeTexture(){
      const c = document.createElement("canvas");
      c.width = 128; c.height = 32;
      const g = c.getContext("2d");
      g.fillStyle = "#f7f1e6"; g.fillRect(0,0,c.width,c.height);
      g.fillStyle = "#c0162b";
      for(let x=-64;x<c.width+64;x+=24){
        g.save(); g.translate(x,0);
        g.beginPath();
        g.moveTo(0,0); g.lineTo(14,0); g.lineTo(24,c.height); g.lineTo(10,c.height);
        g.closePath(); g.fill();
        g.restore();
      }
      const tex = new THREE.CanvasTexture(c);
      tex.colorSpace = THREE.SRGBColorSpace;
      tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
      tex.repeat.set(2.4, 1);
      return tex;
    }
    const stripeTex = makeStripeTexture();

    // materialsï¼ˆæ›´â€œå“‘å…‰ç»¿ + é‡‘å±é‡‘ + çº¢â€ï¼Œå‡å°‘æ³›ç™½ï¼‰
    const goldMat = new THREE.MeshPhysicalMaterial({
      color: 0xc7a54f,
      metalness: 0.95,
      roughness: 0.34,
      clearcoat: 0.55,
      clearcoatRoughness: 0.28,
      emissive: 0x1a1207,
      emissiveIntensity: 0.18
    });
    const redMat = new THREE.MeshPhysicalMaterial({
      color: 0xc0162b,
      metalness: 0.60,
      roughness: 0.40,
      clearcoat: 0.55,
      clearcoatRoughness: 0.30,
      emissive: 0x16050a,
      emissiveIntensity: 0.18
    });
    const greenMat = new THREE.MeshPhysicalMaterial({
      color: 0x1f6b45,
      metalness: 0.35,
      roughness: 0.78,
      clearcoat: 0.35,
      clearcoatRoughness: 0.35,
      emissive: 0x06150f,
      emissiveIntensity: 0.16
    });
    const caneMat = new THREE.MeshPhysicalMaterial({
      color: 0xffffff,
      map: stripeTex,
      metalness: 0.05,
      roughness: 0.28,
      clearcoat: 0.75,
      clearcoatRoughness: 0.18,
      emissive: 0x120407,
      emissiveIntensity: 0.10
    });

    function buildInstanced({count, geometry, material, scaleRange=[0.18,0.32], spin=1.0}){
      const mesh = new THREE.InstancedMesh(geometry, material, count);
      mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
      mesh.frustumCulled = false;
      ROOT.add(mesh);

      const items = new Array(count).fill(0).map((_,i)=>({
        p: conePose(i,count),
        tp: conePose(i,count),
        q: new THREE.Quaternion(),
        tq: new THREE.Quaternion(),
        s: THREE.MathUtils.lerp(scaleRange[0], scaleRange[1], Math.random()),
        ts: 1,
        seed: Math.random()*1000,
        spin: (Math.random()*2-1)*spin
      }));

      for(const it of items){
        it.ts = it.s;
        it.q.setFromEuler(new THREE.Euler(0, it.seed*0.01, 0));
        it.tq.copy(it.q);
      }
      return { mesh, items, tmpM: new THREE.Matrix4(), tmpV: new THREE.Vector3(), tmpE: new THREE.Euler() };
    }

    // å¤šè‰²çƒï¼šé‡‘ + çº¢ï¼ˆé¿å…â€œä¸€ç‰‡é‡‘â€ï¼‰
    const ornamentsGold = buildInstanced({
      count: 220,
      geometry: new THREE.SphereGeometry(0.35, 16, 12),
      material: goldMat,
      scaleRange: [0.22, 0.46],
      spin: 1.0
    });
    const ornamentsRed = buildInstanced({
      count: 140,
      geometry: new THREE.SphereGeometry(0.32, 16, 12),
      material: redMat,
      scaleRange: [0.20, 0.42],
      spin: 1.1
    });
    const cubes = buildInstanced({
      count: 150,
      geometry: new THREE.BoxGeometry(0.6,0.6,0.6),
      material: greenMat,
      scaleRange: [0.22, 0.42],
      spin: 0.8
    });

    function makeCaneGeo(){
      const curve = new THREE.CatmullRomCurve3([
        new THREE.Vector3(0,-0.55,0),
        new THREE.Vector3(0, 0.12,0),
        new THREE.Vector3(0.26,0.42,0),
        new THREE.Vector3(0.48,0.34,0),
        new THREE.Vector3(0.52,0.08,0)
      ]);
      return new THREE.TubeGeometry(curve, 48, 0.10, 10, false);
    }
    const canes = buildInstanced({
      count: 70,
      geometry: makeCaneGeo(),
      material: caneMat,
      scaleRange: [0.5, 0.9],
      spin: 1.2
    });

    // topper starï¼ˆç¨æ”¶æ•›ï¼‰
    function makeStar(){
      const starShape = new THREE.Shape();
      const spikes = 5, outer = 0.62, inner = 0.28;
      for(let i=0;i<spikes*2;i++){
        const a = (i/(spikes*2))*Math.PI*2 - Math.PI/2;
        const r = (i%2===0)? outer : inner;
        starShape.lineTo(Math.cos(a)*r, Math.sin(a)*r);
      }
      starShape.closePath();
      const geo = new THREE.ExtrudeGeometry(starShape, { depth: 0.22, bevelEnabled:true, bevelThickness:0.06, bevelSize:0.04, bevelSegments:2 });
      geo.center();
      const mat = new THREE.MeshPhysicalMaterial({
        color: 0xffd57a,
        metalness: 1.0,
        roughness: 0.25,
        emissive: 0xffb84a,
        emissiveIntensity: 0.65,
        clearcoat: 0.75,
        clearcoatRoughness: 0.18
      });
      const m = new THREE.Mesh(geo, mat);
      m.position.set(0, TREE.baseY + TREE.height + 0.55, 0);
      m.rotation.y = 0.6;
      return m;
    }
    const star = makeStar();
    ROOT.add(star);

    // ---------- sparkle particlesï¼ˆé™ä½å‘å…‰ï¼‰ ----------
    const particleCount = 2300;
    const pGeo = new THREE.BufferGeometry();
    const pPos = new Float32Array(particleCount*3);
    const pSeed = new Float32Array(particleCount);
    for(let i=0;i<particleCount;i++){
      const p = conePose(i, particleCount, 0.85);
      pPos[i*3+0] = p.x;
      pPos[i*3+1] = p.y;
      pPos[i*3+2] = p.z;
      pSeed[i] = Math.random();
    }
    pGeo.setAttribute("position", new THREE.BufferAttribute(pPos, 3));
    pGeo.setAttribute("aSeed", new THREE.BufferAttribute(pSeed, 1));

    const pMat = new THREE.ShaderMaterial({
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending,
      uniforms: { uTime:{value:0} },
      vertexShader: `
        attribute float aSeed;
        uniform float uTime;
        varying float vSeed;
        varying float vTw;
        void main(){
          vSeed = aSeed;
          vec3 pos = position;

          float t = uTime*0.85 + aSeed*12.0;
          float wob = 0.02 + 0.05 * aSeed;
          pos.x += sin(t*1.7) * wob;
          pos.z += cos(t*1.5) * wob;
          pos.y += sin(t*1.1) * wob * 0.6;

          vec4 mv = modelViewMatrix * vec4(pos, 1.0);
          gl_Position = projectionMatrix * mv;

          float tw = 0.45 + 0.55 * sin(t*2.2);
          vTw = tw;

          float size = mix(1.5, 7.5, tw);
          size *= (300.0 / -mv.z);
          gl_PointSize = clamp(size, 1.0, 34.0);
        }
      `,
      fragmentShader: `
        precision highp float;
        varying float vSeed;
        varying float vTw;
        void main(){
          vec2 uv = gl_PointCoord - 0.5;
          float d = length(uv);

          float core = smoothstep(0.26, 0.0, d);
          float halo = smoothstep(0.50, 0.20, d) * 0.35;

          vec3 gold = vec3(1.00, 0.84, 0.48);
          vec3 red  = vec3(0.96, 0.16, 0.26);
          vec3 grn  = vec3(0.18, 0.78, 0.44);

          float sel = fract(vSeed*7.13);
          vec3 c = (sel < 0.55) ? gold : ((sel < 0.78) ? red : grn);

          float a = (core + halo) * (0.32 + 0.50*vTw);
          gl_FragColor = vec4(c * a, a);
        }
      `
    });
    const sparkle = new THREE.Points(pGeo, pMat);
    ROOT.add(sparkle);

    // ---------- photos cloud ----------
    const photoGroup = new THREE.Group();
    ROOT.add(photoGroup);

    const photoPlanes = [];
    const photoRay = new THREE.Raycaster();
    const photoNDC = new THREE.Vector2();

    // 1) é»˜è®¤ç…§ç‰‡ï¼šæ— éœ€ä¸Šä¼ å³å¯çœ‹
    // ä½ å¯ä»¥æŠŠè¿™äº› URL æ¢æˆä½ è‡ªå·±çš„å›¾ç‰‡é“¾æ¥
    const DEFAULT_PHOTO_URLS = [
      // Unsplash ç¤ºä¾‹ï¼ˆHTTPS + æ”¯æŒè·¨åŸŸï¼Œå°½é‡å°ï¼‰
      "https://images.unsplash.com/photo-1543589077-47d81606c1bf?auto=format&fit=crop&w=768&q=70",
      "https://images.unsplash.com/photo-1512389142860-9c449e58a543?auto=format&fit=crop&w=768&q=70",
      "https://images.unsplash.com/photo-1545622783-b3e021430fee?auto=format&fit=crop&w=768&q=70",
      "https://images.unsplash.com/photo-1544198365-2f37f1d23f69?auto=format&fit=crop&w=768&q=70",
      "https://images.unsplash.com/photo-1544185310-0b3cf501672b?auto=format&fit=crop&w=768&q=70",
      "https://images.unsplash.com/photo-1544746428-1b4cfd87ccf9?auto=format&fit=crop&w=768&q=70"
    ];

    function makeProceduralPhoto(i){
      const c = document.createElement("canvas");
      c.width = 512; c.height = 640;
      const g = c.getContext("2d");

      // "photo-like" soft gradient
      const grad = g.createLinearGradient(0,0,512,640);
      grad.addColorStop(0, "#0b2a1d");
      grad.addColorStop(1, "#1f6b45");
      g.fillStyle = grad;
      g.fillRect(0,0,512,640);

      // warm bokeh
      g.globalCompositeOperation = "screen";
      for(let k=0;k<14;k++){
        const x = Math.random()*512, y = Math.random()*640;
        const r = 40 + Math.random()*110;
        const a = 0.05 + Math.random()*0.10;
        g.fillStyle = `rgba(255,213,122,${a})`;
        g.beginPath(); g.arc(x,y,r,0,Math.PI*2); g.fill();
      }

      // snow
      g.globalCompositeOperation = "source-over";
      for(let k=0;k<150;k++){
        const x = Math.random()*512, y = Math.random()*640;
        const s = Math.random()*2.2;
        g.fillStyle = `rgba(255,246,230,${0.15+Math.random()*0.35})`;
        g.beginPath(); g.arc(x,y,s,0,Math.PI*2); g.fill();
      }

      // title
      g.fillStyle = "rgba(255,246,230,.88)";
      g.font = "700 36px system-ui, -apple-system, Segoe UI, sans-serif";
      g.fillText("Merry", 28, 64);
      g.fillText("Christmas", 28, 108);

      const tex = new THREE.CanvasTexture(c);
      tex.colorSpace = THREE.SRGBColorSpace;
      return tex;
    }

    function addPhotoTexture(tex){
      const aspect = 4/5;     // plane w:h
      const w = 1.25;
      const h = w / aspect;

      const geo = new THREE.PlaneGeometry(w, h);
      const mat = new THREE.MeshPhysicalMaterial({
        map: tex,
        roughness: 0.35,
        metalness: 0.02,
        clearcoat: 0.85,
        clearcoatRoughness: 0.18,
        emissive: 0x0e0706,
        emissiveIntensity: 0.12
      });

      const m = new THREE.Mesh(geo, mat);
      m.frustumCulled = false;

      const idx = photoPlanes.length;
      const coneP = conePose(idx, 28, 0.45);
      const scatterP = randomInShell(2.7, 9.5);
      scatterP.y = THREE.MathUtils.clamp(scatterP.y, -1.2, 6.5);

      const item = {
        mesh: m,
        p: coneP.clone(),
        tp: coneP.clone(),
        s: 1.0,
        ts: 1.0,
        coneP,
        scatterP
      };

      m.position.copy(item.p);
      m.lookAt(0, item.p.y, 0);

      photoPlanes.push(item);
      photoGroup.add(m);
      setBadge(hand?.gesture || "â€”");
    }

    async function loadTextureFromUrl(url){
      return await new Promise((resolve, reject)=>{
        const loader = new THREE.TextureLoader();
        loader.setCrossOrigin("anonymous");
        loader.load(url, (t)=>{
          t.colorSpace = THREE.SRGBColorSpace;
          resolve(t);
        }, undefined, reject);
      });
    }

    async function preloadDefaultPhotos(){
      // å…ˆç»™å‡ ä¸ªâ€œå ä½ä¼ªç…§ç‰‡â€ï¼Œä¿è¯é©¬ä¸Šå°±èƒ½çœ‹åˆ°
      for(let i=0;i<6;i++) addPhotoTexture(makeProceduralPhoto(i));

      // å†å¼‚æ­¥å°è¯•ç”¨çœŸå®é»˜è®¤ç…§ç‰‡æ›¿æ¢ï¼ˆæˆåŠŸåˆ™ç»§ç»­åŠ ï¼‰
      for(let i=0;i<DEFAULT_PHOTO_URLS.length;i++){
        try{
          const tex = await loadTextureFromUrl(DEFAULT_PHOTO_URLS[i]);
          addPhotoTexture(tex);
        }catch(e){
          // å¿½ç•¥å¤±è´¥ï¼ˆç½‘ç»œä¸é€š/è·¨åŸŸç­‰ï¼‰
        }
      }
    }

    // ä¸Šä¼ ç…§ç‰‡ï¼ˆä»ä¿ç•™ï¼Œå¯é€‰ï¼‰
    const photosInput = document.getElementById("photosInput");
    photosInput.addEventListener("change", async (e)=>{
      const files = [...(e.target.files||[])].slice(0, 30);
      if(!files.length) return;
      for(const f of files){
        const url = URL.createObjectURL(f);
        try{
          const tex = await loadTextureFromUrl(url);
          addPhotoTexture(tex);
        }catch{}
      }
      photosInput.value = "";
    });

    // ---------- layout ----------
    function resize(){
      const w = innerWidth, h = innerHeight;
      renderer.setSize(w,h);
      composer.setSize(w,h);
      bloom.setSize(w,h);
      camera.aspect = w/h;
      camera.updateProjectionMatrix();
    }
    addEventListener("resize", resize);

    // ---------- retarget ----------
    function setState(next, opts={}){
      state = next;
      if(state !== STATE.PHOTO) selectedPhoto = null;
      if(opts.photo) selectedPhoto = opts.photo;
      retargetAll();
    }

    function retargetAll(){
      const packs = [ornamentsGold, ornamentsRed, cubes, canes];
      for(const pack of packs){
        const items = pack.items;
        for(let i=0;i<items.length;i++){
          const it = items[i];
          if(state === STATE.CONE){
            it.tp.copy(conePose(i, items.length));
          }else{
            const r = 3.2 + (it.seed % 1) * 8.8;
            const ang = (it.seed*1.618) % (Math.PI*2);
            const y = THREE.MathUtils.lerp(-1.6, 6.8, ((Math.sin(it.seed*2.3)+1)*0.5));
            it.tp.set(Math.cos(ang)*r, y, Math.sin(ang)*r);
          }
          pack.tmpE.set(
            ((it.seed*13.1)%1)*Math.PI*2,
            ((it.seed*9.7)%1)*Math.PI*2,
            ((it.seed*7.3)%1)*Math.PI*2
          );
          it.tq.setFromEuler(pack.tmpE);
        }
      }

      for(const ph of photoPlanes){
        if(state === STATE.CONE){
          ph.tp.copy(ph.coneP);
          ph.ts = 0.92;
        }else{
          ph.tp.copy(ph.scatterP);
          ph.ts = 1.0;
        }
      }
    }

    // ---------- camera orbit ----------
    const orbit = { theta: 0, phi: 1.12, r: 14, tTheta: 0, tPhi: 1.12, tR: 14 };
    function updateCamera(dt){
      orbit.theta = damp(orbit.theta, orbit.tTheta, 9, dt);
      orbit.phi   = damp(orbit.phi,   orbit.tPhi,   9, dt);
      orbit.r     = damp(orbit.r,     orbit.tR,     8, dt);
      orbit.phi = clamp(orbit.phi, 0.35, 1.45);

      const x = orbit.r * Math.cos(orbit.theta) * Math.sin(orbit.phi);
      const z = orbit.r * Math.sin(orbit.theta) * Math.sin(orbit.phi);
      const y = orbit.r * Math.cos(orbit.phi) + 0.8;
      camera.position.set(x, y, z);
      camera.lookAt(0, 1.6, 0);
    }

    // ---------- mediapipe hands ----------
    const video = document.getElementById("video");
    const debugWrap = document.getElementById("debugCam");
    const debugCanvas = document.getElementById("debug2d");
    const dbg = debugCanvas.getContext("2d");

    let mpCamera = null;
    let mpHands = null;

    let debugOn = false;
    document.getElementById("toggleDebug").addEventListener("click", ()=>{
      debugOn = !debugOn;
      debugWrap.style.display = debugOn ? "block" : "none";
    });

    const hand = {
      present:false, handedness:"Right", lm:null,
      palm:{x:.5,y:.5}, roll:0,
      pinch:false, pinchDown:false, pinchUp:false,
      gesture:"â€”",
      _lastPinch:false,
      _rollPrev:null
    };

    const lmGet = (i)=>hand.lm?.[i] || null;
    const dist2 = (a,b)=>Math.hypot(a.x-b.x, a.y-b.y);
    function fingerExtended(tip, pip){ return tip.y < pip.y - 0.02; }

    function detectGesture(){
      const lm = hand.lm;
      if(!lm) return "â€”";

      const thumbTip = lm[4], thumbIp = lm[3];
      const idxTip = lm[8], idxPip = lm[6];
      const midTip = lm[12], midPip = lm[10];
      const ringTip = lm[16], ringPip = lm[14];
      const pkyTip = lm[20], pkyPip = lm[18];

      const iEx = fingerExtended(idxTip, idxPip);
      const mEx = fingerExtended(midTip, midPip);
      const rEx = fingerExtended(ringTip, ringPip);
      const pEx = fingerExtended(pkyTip, pkyPip);

      const isRight = (hand.handedness || "Right") === "Right";
      const tEx = isRight ? (thumbTip.x > thumbIp.x + 0.015) : (thumbTip.x < thumbIp.x - 0.015);

      const allOpen = iEx && mEx && rEx && pEx && tEx;
      const allClosed = !iEx && !mEx && !rEx && !pEx && !tEx;

      const wrist = lm[0];
      const midMcp = lm[9];
      const handSize = Math.max(0.001, dist2(wrist, midMcp));
      const pinchD = dist2(thumbTip, idxTip);
      const pinch = pinchD < handSize * 0.45;

      hand.pinch = pinch;
      hand.pinchDown = (!hand._lastPinch && pinch);
      hand.pinchUp = (hand._lastPinch && !pinch);
      hand._lastPinch = pinch;

      if(pinch) return "PINCH";
      if(allOpen) return "PALM";
      if(allClosed) return "FIST";
      return "MOVE";
    }

    const gestureDebounce = { cur:"â€”", cand:"â€”", t:0, hold:0.16 };
    function updateDebouncedGesture(next, dt){
      if(next === gestureDebounce.cur){
        gestureDebounce.cand = next; gestureDebounce.t = 0; return gestureDebounce.cur;
      }
      if(next !== gestureDebounce.cand){
        gestureDebounce.cand = next; gestureDebounce.t = 0;
      }else{
        gestureDebounce.t += dt;
        if(gestureDebounce.t >= gestureDebounce.hold){
          gestureDebounce.cur = gestureDebounce.cand;
          gestureDebounce.t = 0;
        }
      }
      return gestureDebounce.cur;
    }

    function onResults(results){
      hand.present = !!(results.multiHandLandmarks && results.multiHandLandmarks.length);
      if(!hand.present){ hand.lm = null; return; }
      hand.lm = results.multiHandLandmarks[0];
      hand.handedness = results.multiHandedness?.[0]?.label || "Right";

      const w = hand.lm[0], i = hand.lm[5], p = hand.lm[17];
      hand.palm.x = (w.x + i.x + p.x) / 3;
      hand.palm.y = (w.y + i.y + p.y) / 3;

      const dx = i.x - p.x;
      const dy = i.y - p.y;
      hand.roll = Math.atan2(dy, dx);

      if(debugOn){
        const iw = results.image?.width || 640;
        const ih = results.image?.height || 480;
        debugCanvas.width = iw; debugCanvas.height = ih;
        dbg.clearRect(0,0,iw,ih);
        dbg.drawImage(results.image, 0,0,iw,ih);
        drawConnectors(dbg, hand.lm, HAND_CONNECTIONS, {color:"#ffd57a", lineWidth:3});
        drawLandmarks(dbg, hand.lm, {color:"#c0162b", lineWidth:1, radius:2});
      }
    }

    async function initMediaPipe(){
      mpHands = new Hands({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/${file}`
      });
      mpHands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.72,
        minTrackingConfidence: 0.72
      });
      mpHands.onResults(onResults);

      // æ‰‹æœºä¸Šæ›´ç¨³ï¼šideal 640x480 + user camera
      mpCamera = new Camera(video, {
        onFrame: async () => { await mpHands.send({ image: video }); },
        width: 640,
        height: 480
      });
      mpCamera.start();
    }

    // ---------- pinch pick photo ----------
    function raycastPhotoFromHand(){
      const tip = lmGet(8);
      if(!tip) return null;
      photoNDC.set(tip.x*2-1, -(tip.y*2-1));
      photoRay.setFromCamera(photoNDC, camera);
      const hits = photoRay.intersectObjects(photoPlanes.map(p=>p.mesh), false);
      if(!hits.length) return null;
      const hitMesh = hits[0].object;
      return photoPlanes.find(p=>p.mesh === hitMesh) || null;
    }

    addEventListener("pointerdown", (e)=>{
      if(!photoPlanes.length) return;
      photoNDC.set((e.clientX/innerWidth)*2-1, -(e.clientY/innerHeight)*2+1);
      photoRay.setFromCamera(photoNDC, camera);
      const hits = photoRay.intersectObjects(photoPlanes.map(p=>p.mesh), false);
      if(hits.length){
        const ph = photoPlanes.find(p=>p.mesh===hits[0].object);
        if(ph) setState(STATE.PHOTO, {photo: ph});
      }
    });
    addEventListener("keydown", (e)=>{
      if(e.key === "1") setState(STATE.CONE);
      if(e.key === "2") setState(STATE.SCATTER);
      if(e.key === "Escape") setState(STATE.SCATTER);
    });

    // ---------- animation ----------
    const clock = new THREE.Clock();

    function updateInstanced(pack, dt){
      const m = pack.mesh;
      const items = pack.items;
      const tmpM = pack.tmpM;
      const tmpV = pack.tmpV;

      for(let i=0;i<items.length;i++){
        const it = items[i];

        if(state !== STATE.CONE){
          const t = clock.elapsedTime*0.55 + it.seed;
          it.tp.x += Math.sin(t*0.9) * 0.0018;
          it.tp.z += Math.cos(t*0.8) * 0.0018;
          it.tp.y += Math.sin(t*0.6) * 0.0012;
        }

        it.p.lerp(it.tp, 1 - Math.exp(-dt*8.5));
        it.q.slerp(it.tq, 1 - Math.exp(-dt*7.0));

        const spin = it.spin * dt * 0.7;
        const dq = new THREE.Quaternion().setFromEuler(new THREE.Euler(spin*0.5, spin, spin*0.35));
        it.q.multiply(dq);

        tmpM.compose(it.p, it.q, tmpV.setScalar(it.s));
        m.setMatrixAt(i, tmpM);
      }
      m.instanceMatrix.needsUpdate = true;
    }

    function facePhotos(dt){
      for(const ph of photoPlanes){
        if(state === STATE.CONE){
          ph.tp.copy(ph.coneP);
          ph.ts = 0.92;
        }else if(state === STATE.SCATTER){
          ph.tp.copy(ph.scatterP);
          ph.ts = 1.0;
        }else if(state === STATE.PHOTO){
          if(ph === selectedPhoto){
            const fwd = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion).normalize();
            ph.tp.copy(camera.position.clone().add(fwd.multiplyScalar(3.2)));
            ph.ts = 2.25;
          }else{
            ph.tp.copy(ph.scatterP);
            ph.ts = 0.92;
          }
        }

        ph.p.lerp(ph.tp, 1 - Math.exp(-dt*8.0));
        ph.s = damp(ph.s, ph.ts, 9, dt);

        ph.mesh.position.copy(ph.p);
        ph.mesh.scale.setScalar(ph.s);

        if(state === STATE.CONE){
          const outward = ph.p.clone().setY(ph.p.y).normalize();
          const look = ph.p.clone().add(outward);
          ph.mesh.lookAt(look.x, ph.p.y, look.z);
        }else{
          ph.mesh.lookAt(camera.position);
        }

        const mat = ph.mesh.material;
        if(mat && mat.emissive){
          mat.emissiveIntensity = (state === STATE.PHOTO)
            ? (ph === selectedPhoto ? 0.22 : 0.06)
            : 0.12;
        }
      }
    }

    function updateStar(dt){
      star.rotation.y += dt * 0.40;
      const breathe = 0.93 + 0.07*Math.sin(clock.elapsedTime*1.9);
      star.scale.setScalar(breathe);
    }

    function updateSparkle(dt){
      pMat.uniforms.uTime.value = clock.elapsedTime;
      vignettePass.uniforms.uTime.value = clock.elapsedTime * 0.75;
      if(state !== STATE.CONE){
        sparkle.scale.lerp(new THREE.Vector3(1.12,1.03,1.12), 1 - Math.exp(-dt*3.5));
      }else{
        sparkle.scale.lerp(new THREE.Vector3(1,1,1), 1 - Math.exp(-dt*3.5));
      }
    }

    function updateGestures(dt){
      if(!hand.present || !hand.lm){
        hand.gesture = "â€”";
        setBadge(hand.gesture);
        orbit.tTheta = damp(orbit.tTheta, 0, 1.2, dt);
        orbit.tPhi   = damp(orbit.tPhi,   1.12, 1.2, dt);
        orbit.tR     = damp(orbit.tR,     14, 1.2, dt);
        return;
      }

      const raw = detectGesture();
      const g = updateDebouncedGesture(raw, dt);
      hand.gesture = g;
      setBadge(hand.gesture);

      if(g === "FIST"){
        if(state !== STATE.CONE) setState(STATE.CONE);
      }else if(g === "PALM"){
        if(state !== STATE.SCATTER) setState(STATE.SCATTER);
      }

      if(hand.pinchDown){
        const ph = raycastPhotoFromHand();
        if(ph) setState(STATE.PHOTO, {photo: ph});
      }
      if(hand.pinchUp){
        if(state === STATE.PHOTO) setState(STATE.SCATTER);
      }

      if(state !== STATE.CONE){
        orbit.tPhi = 0.85 + (0.5 - hand.palm.y) * 0.95;
        orbit.tPhi = clamp(orbit.tPhi, 0.4, 1.35);

        if(hand._rollPrev == null) hand._rollPrev = hand.roll;
        let dRoll = hand.roll - hand._rollPrev;
        if(dRoll > Math.PI) dRoll -= Math.PI*2;
        if(dRoll < -Math.PI) dRoll += Math.PI*2;
        orbit.tTheta += dRoll * 0.9;
        hand._rollPrev = hand.roll;

        orbit.tR = hand.pinch ? 13.2 : 14.0;
      }else{
        hand._rollPrev = null;
      }
    }

    function tick(){
      const dt = Math.min(0.033, clock.getDelta());

      updateGestures(dt);
      updateCamera(dt);

      if(state !== STATE.CONE){
        ROOT.rotation.y = damp(ROOT.rotation.y, Math.sin(clock.elapsedTime*0.15)*0.10, 2.5, dt);
      }else{
        ROOT.rotation.y = damp(ROOT.rotation.y, 0, 3.2, dt);
      }

      updateInstanced(ornamentsGold, dt);
      updateInstanced(ornamentsRed, dt);
      updateInstanced(cubes, dt);
      updateInstanced(canes, dt);

      facePhotos(dt);
      updateStar(dt);
      updateSparkle(dt);

      // Bloom åŠ¨æ€ï¼ˆä½†æ•´ä½“æ¯”åŸæ¥æ›´å…‹åˆ¶ï¼‰
      const targetBloom = (state === STATE.PHOTO) ? 0.78 : (state === STATE.SCATTER ? 0.62 : 0.52);
      bloom.strength = damp(bloom.strength, targetBloom, 2.5, dt);

      composer.render();
      requestAnimationFrame(tick);
    }

    // ---------- start / gate ----------
    const gate = document.getElementById("gate");
    const gateStart = document.getElementById("gateStart");
    const gateNoCam = document.getElementById("gateNoCam");
    const startBtn = document.getElementById("startBtn");

    async function start(withCamera=true){
      gate.style.display = "none";

      // å…ˆåŠ è½½é»˜è®¤ç…§ç‰‡ï¼ˆä¸ä¸Šä¼ ä¹Ÿèƒ½çœ‹åˆ°ï¼‰
      await preloadDefaultPhotos();
      retargetAll();

      if(withCamera){
        try{
          const stream = await navigator.mediaDevices.getUserMedia({
            video: { facingMode: "user", width: {ideal: 640}, height: {ideal: 480} },
            audio: false
          });
          video.srcObject = stream;
          await video.play();
          await initMediaPipe();
        }catch(err){
          console.warn("Camera permission failed:", err);
        }
      }

      resize();
      tick();
    }

    gateStart.addEventListener("click", ()=>start(true));
    gateNoCam.addEventListener("click", ()=>start(false));
    startBtn.addEventListener("click", ()=>start(true));

    setBadge("â€”");
  </script>
</body>
</html>
